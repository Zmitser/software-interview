---
title: Сходства и различия Kafka и RabbitMQ
tags:
- microservice 
created: 2021-04-07
---

###### СХОДСТВА APACHE KAFKA И RABBITMQ

* **Прикладное назначение** – Apache Kafka и RabbitMQ являются брокерами программных сообщений и используются для обмена информацией между различными приложениями.
* **Схема обмена сообщениями** – оба брокера работают по схеме «издатель-подписчик» (отправитель-получатель), когда источники данных направляют потоки информации, а получатели обрабатывают их по мере потребности.
* **Потоки и пакеты сообщений** – Кафка и Кролик в первую очередь позиционируются для работы с непрерывными потоками информации, однако, они позволяют объединять сообщения в пакеты. Kafka делает это более явно, повышая эффективность от пакетирования благодаря своим возможностям по распределению пакетов, а в RabbitMQ пакетирование является скорее «мнимым» из-за пассивной модели приёма, не препятствующей конфликтам получателей.
* **Уведомления о сообщениях** – Kafka и RabbitMQ обмениваются сигналами с отправителями и получателями при отправке и получении сообщений. 
* **Стратегии доставки** – оба брокера способны реализовать стратегии «как максимум однократная доставка» и «как минимум однократная доставка», что позволяет сократить риски потери или дублирования сообщений.
* **Репликация** – обе системы обеспечивают репликацию сообщений.
* **Гарантии отправки** – Apache Kafka и RabbitMQ гарантируют порядок отправки сообщений с помощью уведомлений и стратегий доставки.

###### ЧЕМ КАФКА ОТЛИЧАЕТСЯ ОТ КРОЛИКА

Основные отличия Apache Kafka и RabbitMQ обусловлены принципиально **разными моделями доставки сообщений**, реализуемыми в этих системах. В частности, Kafka действует по принципу вытягивания (pull), когда получатели (consumers) сами достают из топика (topic) нужные им сообщения. RabbitMQ, напротив, реализует модель проталкивания, отправляя необходимые сообщения получателям. В связи с этим Кафка отличается от Кролика по следующим критериям:
* **Сохранение сообщений** – RabbitMQ помещает сообщение в очередь FIFO (First Input – First Output) и отслеживает статус этого сообщения в очереди, а Kafka добавляет сообщение в журнал (записывает на диск), предоставляя получателю самому заботиться о получении нужной информации из топика. Кролик удаляет сообщение после доставки его получателю, а Кафка хранит сообщение до тех пор, пока не наступит момент запланированной очистки журнала. Таким образом, Apache Kafka сохраняет текущее и все прежние состояния системы и может использоваться в качестве достоверного источника исторических данных, в отличие от RabbitMQ.
* **Балансировка** – благодаря pull-модели доставки сообщений RabbitMQ сокращает время задержки, однако возможно переполнение получателей, если сообщения прибудут в очередь быстрее, чем те могут их обработать. Поскольку в RabbitMQ каждый получатель запрашивает/выгружает разное количество сообщений, то распределение работы может стать неравномерным, что повлечет задержки и потерю порядка сообщений во время обработки. Для предупреждения этого каждый получатель Кролика настраивает предел предварительной выборки (QoS) – ограничение на количество скопившихся неподтвержденных сообщений. В Apache Kafka балансировка нагрузки выполняется автоматически путем перераспределения получателей по разделам (partition) топика.
* **Пропускная способность** – Kafka гарантирует порядок сообщений в разделе топика (partition) без конкурирующих получателей, что позволяет объединять сообщения в пакеты для более эффективной доставки и повышает пропускную способность системы.
* **Масштабируемость** – Кафка считается более адаптивной к масштабированию, обеспечивая ежедневный обмен миллиардами сообщений. Однако, стоит отметить, что далеко на каждый Big Data проект нуждается в таких высоких цифрах.
* **Маршрутизация** – RabbitMQ включает 4 способа маршрутизации на разные обменники (exchange) для постановки в различные очереди, что позволяет использовать мощный и гибкий набор шаблонов обменов сообщениями. Кафка реализует лишь 1 способ записи сообщений на диск, без маршрутизации.
* **Упорядочивание сообщений** – Кролик позволяет поддерживать относительный порядок в произвольных наборах (группах) событий, а Кафка обеспечивает простой способ поддержания упорядочения с поддержкой масштабирования путем последовательной записи сообщений в реплицированный журнал (топик).
* **Работа с клиентом** – про Apache Kafka говорят «тупой сервер, умный клиент», что означает необходимость реализации логики работы с сообщениями на клиентской стороне, т.е consumer заботится о получении нужных сообщений. RabbitMQ – наоборот, «умный сервер, тупой клиент», поскольку этот брокер сам обеспечивает всю логику работы с сообщениями.
